2.1 데이터 추상화

> 데이터 추상화: 우리가 어떠한 복합 데이터 객체가 쓰이는 방식과 그 복합 데이터를 좀더 기본적인 데이터 객체들로 구축하는 구체적인 방식을 분리할 수 있게 하는 방법론이다.

- 생성자: 분자와 분모로 유리수를 만드는 수단
- 선택자: 주어진 유리수에서 분자와 분모를 추출하는 수단

추상화 장벽

- 추상화 장벽 위에 있는 프로그램은 그 아래 있는 프로그램의 데이터 추상들을 활용한다.
- 전체 시스템에서 쌍 객체 장벽보다 위에 있는 프로그램들은 쌍 객체를 그냥 조작할 뿐, 쌍 객체가 어떻게 구현되는지는 알지 못하고 알 필요도 없다.
- 본질적으로 각 수준의 함수들은 추상화 장벽을 정의하고 서로 다른 수준들을 연결하는 인터페이스로 작용한다.

추상화 장벽의 장점

- 프로그램을 관리(유지보수)하고 수정하기가 훨씬 쉽다.
- 그 어떤 복잡한 자료구조라도 원시 자료 구조를 이용해서 다양한 방식으로 표현할 수 있다.

ex) 코드를 수정할 때 실제 유리수 연산을 구현하는 함수는 전혀 고치지 않고 생성자만 고쳐서 문제를 해결할 수도있고 선택자만 고쳐서 해결할 수도 있다.(생성과 접근의 빈도에 띠라. 자바의 list 생각)
데이터 추상화 방법론은 이런 결정을 뒤로 미룬채로도 시스템의 나머지 부분을 계소 개발해나갈 수 있는 유연성을 제공한다.

### 느낀점

- 분수로 데이터 추상화 예시를 보고 진짜 좋은 추상화 예시를 봤다는 생각을 했다. 코드의 내용이 어렵지는 않지만 이렇게 만드는건 쉬운게 아니다. 책을 보기전에 누가 나에게 이런 퀴즈를 냈으면 내 지금 능력을 확인할 수 있었을텐데... 아쉽다.

예전에 코드스피츠 강의를 들을때 강사님이 이런 얘기를 한적이 있다. [개인블로그](https://ms3864.tistory.com/444)

> 객체지향에서 내부 구현은 중요하지 않다. 내장을 깔 필요도 없다. 선언형 프로그래밍, 추상화와 관련된 내용이다. 내장을 까야된다면 그건 잘못된 코드다. 또한 호스트가 중요하지 객체는 중요하지 않다. 그냥 호스트에게 잘 가면된다. 예를 들어서 특정 함수를 실행했을 때 결과값만 잘 받으면 된다. 내부에서 무슨 일이 발생하는지는 전혀 중요하지 않다.(중요하지 않다는건 상위 컨텍스트 입장에서 중요하지 않다는 것이지 내부에 함수 내부 코드를 막 짜도 된다는 얘기는 아니다.)

추상화장벽이라는 용어는 얘기하지 않았지만 추상화장벽을 얘기한 것이다.

그리고 [컴포넌트 관련된 글](https://ms3864.tistory.com/433)을 썼을때 인터페이스에 대해서 찾아보고 공부한적이 있었다. 그리고 [한재엽님의 글](https://jbee.io/web/components-should-be-flexible/)에서 다음과 같이 말한다.

1. 인터페이스는 사용하는 쪽을 위한 것이다.
2. 컴포넌트를 사용하는 쪽에선 인터페이스를 보고 어떻게 동작할지 예상 가능해야 한다.

이걸 바탕으로 컴포넌트 혹은 함수를 설계하고 수정해보니 훨씬 좋은 코드가 되었음을 크게 느낄 수 있었다. 클래스도 아니고 무슨 개별적인 컴포넌트나 함수에 추상화장벽이냐라고 말할 수 있지만 분명히 추상화장벽의 개념을 적용하면 더 좋아진다. 예를들어서 컴포넌트를 상위 컴포넌트에 의존적으로 인터페이스를 만들수도 있지만 독립적으로 만들수도 있다.
